#!/usr/bin/env ruby
#
# © Johannes Krude 2008
#
# This file is part of sendfile-utils.
#
# broadcast-files is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# broadcast-files is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
#

$version= "pre 0.1α"

$: << "./lib"
require 'optparse'
require 'pathname'
require 'sendhttp-lib/httpserver'
require 'sendhttp-lib/html'

$verbose= 1

class SendhttpArgs < OptionParser


	attr_reader :files

	def initialize
		super
		@options= Hash.new
	@files= Hash.new
		self.banner= "Usage: sendhttp [options] <file [@ name]>*"

		@options[:count]= 1.0/0
		self.on("-c NUM", "--count NUM", "make each file only NUM times accesible") do |num|
			@options[:count]= num.to_i
		end

		@options[:get]= false
		self.on("-g", "--get", "receive a file instead of sending it") do
			@options[:get]= true
		end

		self.on("-h", "--help", "display this message") do
			STDOUT.puts self
			exit 0
		end

		@options[:listing]= false
		self.on("-l", "--listing", "enable directory listing") do
			@options[:listing]= true
		end

		@options[:port]= 12345
		self.on("-p PORT", "--port PORT", Integer, "Listen on port PORT") do |port|
			@options[:port]= port.to_i
		end

		@options[:quit]= 1.0/0
		self.on("-q NUM", "--quit NUM", Integer, "quit after NUM succesfull downloads") do |num|
			@options[:quit]= num
		end

		@options[:timeout]= 1.0/0 #Infinity
		self.on("-t SECONDS", "--timeout SECONDS", Float, "wait SECONDS for a request") do |timeout|
			@options[:timeout]= timeout
		end

		self.on("-v", "--version", "display the version number") do
			STDOUT.puts $version
			exit 0
		end

	end

	def [](key)
		@options[key.to_sym]
	end

	def []=(key, value)
		@options[key.to_sym]= value
	end

	def SendhttpArgs.find(dir= ".")
		Dir.new(dir).collect do |f|
			next if f=~ /^\./
			next if FileTest.symlink?(f)
			if FileTest.directory?(f)
				find(f).collect { |g| f+"/"+g }
			else
				f
			end
		end.delete_if { |x| !x }.flatten
	end

	def files_expand
		@files.each_key do |k|
			if FileTest.symlink?(@files[k])
				@files.delete(k)
			elsif FileTest.directory?(@files[k])
				find(@files[k]).each do |f|
					if k == "."
						@files[f]= @files[k]+"/"+f
					else
						@files[k+"/"+f]= @files[k]+"/"+f
					end
				end
				@files.delete(k)
			else
				unless @files[k]=="-" or self[:get] or File.exists?(@files[k]) # we can write to a non existing file with (-g|--get)
					raise "File '#{@files[k]}' does not exist"
				end
			end
		end
	end
	private :files_expand

	def parse(array)
		array= super(array) # parse the switches (-s|--something)
		while i= array.index("@")
			raise "wrong '@' argument" unless (1..array.size-1).include?(i)
			raise "wrong '@' argument" if array[i-1] == "@" or array[i+1] == "@"
			@files[array[i+1]]= array[i-1]
			array.delete_at(i+1)
			array.delete_at(i)
			array.delete_at(i-1)
		end
		array.each do |file|
			@files[file]= file
		end
		files_expand
	end

end


begin

	options= SendhttpArgs.new
	options.parse(ARGV)

	unless options.files.size > 0
		STDERR.puts "No filename given"
		exit 1
	end

	file_count= Hash.new(options[:count])
	file_count["-"]= 1

	server= HTTPServer.new
	server.listen(options[:port]) do |filename, vars|
		case
		when file= options.files[filename]
			if options[:get]
				unless vars["form-data"] and vars["form-data"]["upload"]
					HTML.base(HTML.h1("Please upload something")+HTML.div(HTML.form(" action=\"\" method=\"post\" enctype=\"multipart/form-data\"", HTML.input("hidden", " name=\"upload\"")+HTML.input("file", " name=\"file\"")+HTML.input("submit", " value=\"send\""))))
				else
					options[:quit]-= 1
					server.close if options[:quit]==0
					file_count[filename]-= 1
					options.files.delete(filename) if file_count[filename] == 0
					server.close if options.files.keys.size == 0
					if file == "-"
						STDOUT.write(vars["form-data"]["file"])
					else
						File.open(file, "w").write(vars["form-data"]["file"])
					end
					HTML.base(HTML.h1("Upload Complete")+HTML.div(HTML.list(options.files.keys.sort.collect { |k| HTML.a(k, "/#{k}") } )))
				end
			else
				options[:quit]-= 1
				server.close if options[:quit]==0
				file_count[filename]-= 1
				options.files.delete(filename) if file_count[filename] == 0
				server.close if options.files.keys.size == 0
				if file == "-"
					STDIN
				else
					HTTPServer.put_file(file)
				end
			end
		when options[:listing]
				[HTML.base(HTML.h1("The following files are available")+HTML.div(HTML.list(options.files.keys.sort.collect { |k| HTML.a(k, "/#{k}") } ))), nil, "404 NOT FOUND"]
		else
			false
		end
	end

rescue RuntimeError => e
	STDERR.puts e.message
	exit 1
rescue OptionParser::MissingArgument => e
	STDERR.puts "Missing argument for '#{e.args}'"
	exit 1
rescue OptionParser::InvalidOption => e
	STDERR.puts "Undefined Option '#{e.args}'"
	exit 1
rescue OptionParser::InvalidArgument => e
	STDERR.puts "Invalid argument for '#{e.args}'"
	exit 1
rescue SignalException => e
	STDERR.puts "#{e} aborted"
rescue Interrupt
	STDERR.puts "aborted"
end

