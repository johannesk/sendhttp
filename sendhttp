#!/usr/bin/env ruby
#
# © Johannes Krude 2008
#
# This file is part of sendfile-utils.
#
# broadcast-files is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# broadcast-files is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
#

$version= "pre 0.1α"

$: << "./lib"
require 'optparse'
require 'pathname'
require 'sendhttp-lib/httpserver'
require 'sendhttp-lib/html'

$verbose= 1

begin
	arghandler= OptionParser.new
	
	arghandler.banner= "Usage: sendhttp [options] <file [@ name]>*"

	$get= false
	arghandler.on("-g", "--get", "receive a file instead of sending it") do
		$get= true
	end

	arghandler.on("-h", "--help", "display this message") do
		STDOUT.puts arghandler
		exit 0
	end

	$listing= false
	arghandler.on("-l", "--listing", "enable directory listing") do
		$listing= true
	end

	$port= 12345
	arghandler.on("-p PORT", "--port PORT", Integer, "Listen on port PORT") do |port|
		$port= port.to_i
	end

	$quit= 1.0/0
	arghandler.on("-q NUM", "--quit NUM", Integer, "quit after NUM succesfull downloads") do |num|
		$quit= num
	end

	$timeout= 1.0/0 #Infinity
	arghandler.on("-t SECONDS", "--timeout SECONDS", Float, "wait SECONDS for a request") do |timeout|
		$timeout= timeout
	end

	arghandler.on("-v", "--version", "display the version number") do
		STDOUT.puts $version
		exit 0
	end

	if $get and ($quit != 1.0/0)
		STDERR.puts "(-g|--get) cannot be used togehter with (-q|--quit)"
		exit 1
	end

	def find(dir= ".")
		Dir.new(dir).collect do |f|
			next if f=~ /^\./
			next if FileTest.symlink?(f)
			if FileTest.directory?(f)
				find(f).collect { |g| f+"/"+g }
			else
				f
			end
		end.delete_if { |x| !x }.flatten
	end
	
	$file= Hash.new
	name= false
	last= nil
	(arghandler.parse(ARGV)+[nil]).each do |file|
		case
		when name
			name= false
			$file[file]= last
			last= nil
		when file=="@"
			name= true
		else
			$file[last]= last if last
			last= file
		end
	end
	$file.each_key do |k|
		if !( k and $file[k] and !FileTest.symlink?($file[k]))
			$file.delete(k)
		elsif FileTest.directory?($file[k])
			find($file[k]).each do |f|
				if k == "."
					$file[f]= $file[k]+"/"+f
				else
					$file[k+"/"+f]= $file[k]+"/"+f
				end
			end
			$file.delete(k)
		else
			unless File.exists?($file[k]) or $get # we can write to a non existing file with (-g|--get)
				STDERR.puts "File '#{$file[k]}' does not exist"
				exit 1
			end
		end
	end

	unless $file.size > 0
		STDERR.puts "No filename given"
		exit 1
	end

	if $get and $file.size > 1
		STDERR.puts "you can supply only one filename with (-g|--get)"
		exit 1
	end

	if $get and $file.keys[0]!=$file.values[0]
		STDERR.puts "there is no point in renaming a file, filenames are never anounced with (-g|--get)"
		exit 1
	end

	server= HTTPServer.new
	if $get
		server.listen($port) do |filename, vars|
			unless vars["form-data"] and vars["form-data"]["upload"]
				HTML.base(HTML.h1("Please upload something")+HTML.div(HTML.form(" action=\"\" method=\"post\" enctype=\"multipart/form-data\"", HTML.input("hidden", " name=\"upload\"")+HTML.input("file", " name=\"file\"")+HTML.input("submit", " value=\"send\""))))
			else
				File.open($file.values[0], "w").write(vars["form-data"]["file"])
				HTML.base(HTML.h1("Upload complete"))
			end
		end
	else
		server.listen($port) do |filename, vars|
			case
			when $file[filename]
				$quit-= 1
				server.close if $quit==0
				HTTPServer.put_file($file[filename])
			when $listing
					[HTML.base(HTML.h1("The following files are available")+HTML.div(HTML.list($file.keys.sort.collect { |k| HTML.a(k, "/#{k}") } ))), nil, "404 NOT FOUND"]
			else
				false
			end
		end
	end

rescue OptionParser::MissingArgument => e
	STDERR.puts "Missing argument for '#{e.args}'"
	exit 1
rescue OptionParser::InvalidOption => e
	STDERR.puts "Undefined Option '#{e.args}'"
	exit 1
rescue OptionParser::InvalidArgument => e
	STDERR.puts "Invalid argument for '#{e.args}'"
	exit 1
rescue SignalException => e
	STDERR.puts "#{e} aborted"
rescue Interrupt
	STDERR.puts "aborted"
end

